#include <iostream>
#include <algorithm>
/*
유현이가 인범이에게 알려준 퍼즐은 일렬로 놓여있는 계란에 대해 왼쪽부터 차례로 들어서 한 번씩만 다른 계란을 쳐 최대한 많은 계란을 깨는 문제였다. 구체적으로 계란을 치는 과정을 설명하면 아래와 같다.

가장 왼쪽의 계란을 든다.
손에 들고 있는 계란으로 깨지지 않은 다른 계란 중에서 하나를 친다.
단, 손에 든 계란이 깨졌거나 깨지지 않은 다른 계란이 없으면 치지 않고 넘어간다.
이후 손에 든 계란을 원래 자리에 내려놓고 3번 과정을 진행한다.
가장 최근에 든 계란의 한 칸 오른쪽 계란을 손에 들고 2번 과정을 다시 진행한다. 
단, 가장 최근에 든 계란이 가장 오른쪽에 위치한 계란일 경우 계란을 치는 과정을 종료한다.
이 과정을 통해 최대한 많은 계란을 깨는 것이 앞으로 인범이가 매일 아침마다 풀게 될 퍼즐이다. 
그리고 유현이는 인범이가 찾은 답이 정답이 맞는지 확인해주려고 한다. 
일렬로 놓인 계란들의 내구도와 무게가 차례대로 주어졌을 때 최대 몇 개의 계란을 깰 수 있는지 알아맞춰보자.

첫째 줄에 계란의 수를 나타내는 N(1 ≤ N ≤ 8)가 주어진다.
그 다음 N개의 줄에는 계란의 내구도와 무게에 대한 정보가 주어진다. 
i+1번째 줄에는 왼쪽에서 i번째에 위치한 계란의 내구도 Si(1 ≤ Si ≤ 300)와 무게 Wi(1 ≤ Wi ≤ 300)가 한 칸의 빈칸을 사이에 두고 주어진다.

*/

using namespace std;

int N;
int ans = 0;
int w[10];
int s[10];
int cnt = 0;

void BT(int k) {
	
	// 모든 계란을 집었을 때
	if (k == N) {
		ans = max(cnt, ans);
		return;
	}

	// 집은 계란이 깨지거나 모든 계란이 깨졌을 때
	if (s[k] <= 0 || cnt == N-1) {
		BT(k + 1); // 다음 실행
		return;
	}
	
	for (int i = 0; i < N; i++) {
		if (k == i || s[i] <=0) continue;
		s[k] -= w[i]; //집어든 계란의 내구도 삭감
		s[i] -= w[k]; // 친 계란의 내구도 삭감
		if (s[k] <= 0) // 들고 있는 계란이 깨진겨우
			cnt++;
		if (s[i] <= 0) // 친계란이 깨진 경우
			cnt++;
		BT(k + 1);
		if (s[k] <= 0) //계란 상태에 따라 깨진 계란수 원상복구
			cnt--;
		if (s[i] <= 0)
			cnt--;
		// 내구도 원상 복구
		s[k] += w[i];
		s[i] += w[k];
	}
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL);

	cin >> N;
	for (int i = 0; i < N; i++)
		cin >> s[i] >> w[i];
	BT(0);
	cout << ans << "\n";
	return 0;
}
